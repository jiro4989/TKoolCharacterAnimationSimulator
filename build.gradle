/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * User Manual available at https://docs.gradle.org/6.3/userguide/tutorial_java_projects.html
 */

buildscript {
  repositories {
    mavenCentral()
    maven {
      setUrl("https://plugins.gradle.org/m2/")
    }
  }
}

plugins {
  // Apply the java plugin to add support for Java
  id 'java'

  // Apply the application plugin to add support for building a CLI application.
  id 'application'

  // JavaFX
  id "org.openjfx.javafxplugin" version "0.0.12"

  // Spotless for code formatting
  id "com.diffplug.spotless" version "6.3.0"

  id 'jacoco'
}

repositories {
  mavenCentral()
}

dependencies {
  // This dependency is used by the application.
  implementation 'com.google.guava:guava:31.0.1-jre'

  // Use JUnit test framework
  testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.2'
  testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.8.2'
  testImplementation 'org.junit.platform:junit-platform-launcher:1.8.2'
  testImplementation 'org.junit.jupiter:junit-jupiter-params:5.8.2'
  testImplementation "org.testfx:testfx-junit5:4.0.16-alpha"

  // JavaFX
  implementation "org.openjfx:javafx-fxml:17.0.2"
  implementation "org.openjfx:javafx-base:17.0.2"
  implementation "org.openjfx:javafx-controls:17.0.2"
  implementation "org.openjfx:javafx-graphics:17.0.2"
  implementation "org.openjfx:javafx-swing:17.0.2"
}

sourceCompatibility = 16
targetCompatibility = 16

application {
  // Define the main class for the application.
  getMainClass().set('com.jiro4989.tkcas.Main')
}

compileJava {
  options.encoding = 'UTF-8'
}

javafx {
  modules = [
    'javafx.controls',
    'javafx.fxml',
    'javafx.swing'
  ]
}

jar {
  manifest {
    attributes 'Main-Class': 'com.jiro4989.tkcas.Main'
  }

  archiveBaseName = 'tkcas'

  from {
    configurations.compileClasspath.collect {
      it.isDirectory() ? it : zipTree(it)
    }
  }
  duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

test {
  useJUnitPlatform()
  finalizedBy jacocoTestReport
  jacoco {
    destinationFile = file("${buildDir}/jacoco/test.exec")
  }
}

task junitPlatformJacocoReport(type: JacocoReport) {
  sourceSets sourceSets.main
  executionData test
}

jacocoTestReport {
  reports {
    xml.enabled = true
    html.enabled = true
  }
}

spotless {
  java {
    googleJavaFormat('1.13.0')

    trimTrailingWhitespace()
    endWithNewline()
    removeUnusedImports()
  }

  kotlin {
    ktfmt('0.15')
    //diktat('0.4.0')
  }

  groovyGradle {
    target '*.gradle'
    greclipse().configFile("$rootDir/greclipse.properties")
  }
}

version = 'dev'
if (project.hasProperty('CI_VERSION')) {
  version = CI_VERSION
}
def commitHash = 'dev'
if (project.hasProperty('CI_COMMIT_HASH')) {
  commitHash = CI_COMMIT_HASH
}

def VERSION_JAVA_FILE = 'Version.java'
def SRC_FILE = 'template/' + VERSION_JAVA_FILE

def DST_DIR = 'src/main/java/com/jiro4989/tkcas'
def DST_FILE = DST_DIR + '/' + VERSION_JAVA_FILE

// Version.javaにバージョン番号とコミットハッシュを埋め込んでコピーする。
//
// 環境変数を指定せずにビルドするとdevがデフォルトでセットされる。
// CIでのビルド時にはタグ番号とコミットハッシュが埋め込まれる。
// こうすることでタグ番号の二重管理を防ぐことができる。
task versionSet(type: Copy) {
  doFirst {
    delete DST_FILE
  }
  from SRC_FILE
  into DST_DIR
  expand(version: version, commitHash: commitHash)
}

def libDir = './lib'

task clearDependencies {
  delete libDir
}

// dependenciesで取得したjarファイルをlib配下にコピーする。
//
// runAppで実行するときにライブラリのパスを指定するために使用する。
task dumpDependencies() {
  doLast {
    configurations.compileClasspath.each {
      def jarFile = it.absolutePath
      copy {
        from jarFile
        into libDir
      }
    }
  }
}

def appMods = [
  'javafx.base',
  'javafx.controls',
  'javafx.swing',
  'javafx.graphics',
  'javafx.fxml',
]

task runApp(type: Exec) {
  commandLine 'java',
    '--module-path', libDir,
    '--add-modules', appMods.join(','),
    '-jar', 'build/libs/tkcas-dev.jar'
}

def jmodsDir = './jmods/javafx-jmods-11.0.2'
def customJREDir = 'jre'

if (project.hasProperty('CI_JMODS_DIR')) {
  jmodsDir = CI_JMODS_DIR
}

task clearCustomJRE {
  delete customJREDir
}

// カスタムJREを作成する。
task jlink(type: Exec) {
  commandLine 'jlink',
    '--module-path', jmodsDir,
    '--add-modules', appMods.join(','),
    '--compress=2',
    '--output', customJREDir
}

tasks.register('cleanCustomJRE') {
  group = "Build"
  description = "生成したカスタムJREを削除する"

  doLast {
    delete customJREDir
  }
}

// 実行順序の明示
spotlessApply.dependsOn(['clean'])
versionSet.dependsOn(['spotlessApply'])
test.dependsOn('spotlessApply')
processResources.dependsOn(['versionSet'])
compileJava.dependsOn(['processResources'])
// compileKotlin.dependsOn(['processResources'])
jacocoTestReport.dependsOn(['test'])

dumpDependencies.dependsOn(['cleanDependencies'])
runApp.dependsOn(['dumpDependencies'])

jlink.dependsOn(['cleanCustomJRE'])
